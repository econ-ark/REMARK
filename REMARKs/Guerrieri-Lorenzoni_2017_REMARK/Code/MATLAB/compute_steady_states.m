%============================================================================
%   Compute Initial and Terminal Steady States and Calibrate Baseline Model
%
% Household problem is solved by endogenous grid point method.
%
% Loads inc_process.mat. Loads and saves par.mat, grid.mat, steady.mat
%
% Date : 01/23/2018
%============================================================================

%% Housekeeping
close all;
clear;
clc;

%=========================================================================
%%                          1. Set parameters
%=========================================================================
% Convenient to have parameters from labor supply equation as globals
global theta z fac gameta

% Fixed parameters
gam      = 4;       % risk aversion
frisch   = 1;       % avg Frisch elast.
r        = 2.5/400; % ss interest rate

% Calibration targets
NE       = 0.4;     % avg hours of employed
nu_Y     = 0.4;     % UI benefit per GDP
B_4Y     = 1.6;     % liquid wealth per annual GDP
D1_4Y    = 0.18;    % HH debt to annual GDP in initial ss
D2_4Y    = 0.08;    % HH debt to annual GDP in terminal ss

% Leisure curvature follows right away
eta    = 1/frisch * (1 - NE) / NE;
gameta = gam / eta;

% Numerical parameters
maxit    = 500;   % maximum number of iterations in calibration
cmin     = 1e-6;  % lower bound on consumption
tol_pol  = 1e-10; % tolerance lvl for policy function
tol_dist = 1e-10; % tolerance lvl for distribution
tol_mkt  = 1e-6;  % tolerance lvl for market clearing
tol_cali = 1e-4;  % tolerance lvl for calibration

% Asset grid
I      = 200; % number of grid points
Ic     = 100;
bmin   = -2;   % lower bound
bmax   = 50;   % upper bound
b_grid = bmin + ((1:I)/I).^2 * (bmax - bmin); % denser for low values
db     = 0.01; % step size for MPC

% Income shock process
load inc_process
% 12-state Markov chain for employed states generated by Tauchen's method
% x  : log productivity
% Pr : transition matrix
% pr : invariant distribution

% Add unemployment
theta = [0; exp(x)];
S     = length(theta);
fin   = 0.8820;        % job-finding probability
sep   = 0.0573;        % separation probability

% new transition matrix
Pr = [1-fin, fin*pr; sep*ones(S-1, 1), (1-sep)*Pr];

% find new invariate distribution
pr  = [0, pr];
dif = 1;
while dif > tol_dist
  pri = pr*Pr;
  dif = max(abs(pri-pr));
  pr  = pri;
end

% Initial guesses for calibrated parameters, NE ~ Y
bet  = 0.8^(1/4);              % discount factor
nu   = nu_Y  * NE;             % UI benefits
B    = B_4Y  * NE * 4;         % net supply of bonds
phi1 = D1_4Y * NE * 2;         % borrowing constraint in initial ss
phi2 = D2_4Y * NE * 2;         % borrowing constraint in terminal ss
pssi = NE^(-gam) * (1-NE)^eta; % disutility from labor as if representative agent

% Set rerun_initial = 1 for immediate calibration.
rerun_initial  = 1;
rerun_terminal = 1;

%=========================================================================
%%                 2. Calibrate on Initial Steady State
%=========================================================================
if rerun_initial == 1
  load par;
end

% Set relevant borrowing constraint
phi = phi1;

% Preallocation
cl    = ones(1, S);  % consumption at borrowing constraint
n_pol = zeros(S, I); % labor policy
y_pol = zeros(S, I); % production policy
b_pol = zeros(S, I); % savings policy
mpcs  = zeros(S, I); % MPCs


disp('Computing initial equilibrium...');
for it = 1:maxit
  % Update budget constraint
  tau = (pr(1)*nu + r/(1+r)*B) / (1 - pr(1)); % labor tax
  z   = [nu, -tau*ones(1,S-1)];               % full transfer scheme (tau tilde in paper)

  % Find consumption at the lower bound of the state space
  fac = (pssi ./ theta) .^ (1/eta);
  for s = 1:S
    cl(s) = fzero('find_cl',...      % objective
                  [cmin, 100],...    % interval for bisection
                  [],...             % options
                  s, -phi, -phi, r); % state, assets, interest rate
  end

  % A) Solve for consumption policy
  %----------------------------------
  % Initial guess for policy function
  c_pol  = max(cmin, r*ones(S,1) * b_grid);
  c_poli = c_pol;                           % next iteration

  dif = 1;
  while dif > tol_pol
    % expected marginal utility tomorrow
    ui = Pr * c_pol.^(-gam);
    ui = ui(:, b_grid >= -phi);

    for s=1:S
      % unconstrained
      c = ((1+r) * bet * ui(s, :)) .^ (-1/gam);                   % Euler
      n = max(0, 1 - fac(s)*c.^gameta);                           % labor supply
      b = b_grid(b_grid >= -phi) / (1+r) + c - theta(s)*n - z(s); % budget

      % constrained
      if b(1) > -phi
          c_c = linspace(cl(s), c(1), Ic);
          n_c = max(0, 1 - fac(s)*c_c.^gameta);         % labor supply
          b_c = -phi/(1+r) + c_c - theta(s)*n_c - z(s); % budget
          b   = [b_c(1:Ic-1), b];
          c   = [c_c(1:Ic-1), c];
      end

      c_poli(s, :) = interp1(b, c, b_grid, 'linear', 'extrap');
    end

    % check convergence
    c_poli = max(c_poli, cmin);
    dif    = max(max(abs(c_poli - c_pol)));

    % update
    c_pol = c_poli;
  end

  % Save other policy functions and MPCs
  for s = 1:S
    n_pol(s, :) = max(0, 1 - fac(s)*c_pol(s, :).^gameta);
    y_pol(s, :) = theta(s) * n_pol(s, :);
    b_pol(s, :) = max((1+r) * (b_grid + y_pol(s, :) - c_pol(s,:) + z(s)), -phi);
    mpcs(s, :)  = (interp1(b_grid, c_pol(s,:), b_grid + db, 'linear', 'extrap') - c_pol(s,:)) / db;
  end

  % B) Find invariant distribution
  %----------------------------------
  % Assign weights to adjacent grid points proportionally to distance
  [~, ib_pol] = histc(b_pol, b_grid);
  wei         = (b_pol - b_grid(ib_pol)) ./ (b_grid(ib_pol+1) - b_grid(ib_pol));

  % Iterate asset transition matrix starting from uniform distribution
  dif = 1;
  pd  = ones(S,I) / (S*I);
  while dif > tol_dist
    pdi = zeros(S, I);
    for s = 1:S
      for i = 1:I
        for si = 1:S
          pdi(si, ib_pol(s, i))     = (1 - wei(s, i)) * Pr(s, si) * pd(s, i) + pdi(si, ib_pol(s, i));
          pdi(si, ib_pol(s, i) + 1) = wei(s, i)       * Pr(s, si) * pd(s, i) + pdi(si, ib_pol(s, i) + 1);
        end
      end
    end

    % check convergence
    dif = max(max(abs(pdi - pd)));

    % make sure that distribution integrates to 1
    pd = pdi / sum(sum(pdi));
  end

  % C) Check market clearing and calibration
  %-------------------------------------------------
  % Bond market clearing, i refers to current iteration
  Bi      = sum(sum(pd) .* b_grid);
  res_mkt = abs(B - Bi);

  % Calibration statistics, i refers to current iteration
  Yi    = sum(sum(pd  .* y_pol));                                      % GDP
  NEi   =  sum(sum(pd.*n_pol.*(n_pol>0))) / sum(sum(pd .* (n_pol>0))); % avg hours of employed
  B_4Yi =  Bi / Yi / 4;                                                % debt ratio
  Di    = -sum(sum(pd) .* min(b_grid, 0));
  D_4Yi =  Di / Yi / 4;                                                % debt ratio
  nu_Yi =  nu / Yi;                                                    % UI benefit ratio
  res_cali = max(abs([B_4Yi, D_4Yi, nu_Yi, NEi] - [B_4Y, D1_4Y, nu_Y, NE]));

  % Report convergence
  disp(['Iteration ', num2str(it)]);
  disp(['Bond mkt clearing: ', num2str(B - Bi)]);
  disp(['Liquid wealth:     ', num2str(B_4Yi - B_4Y)]);
  disp(['Debt to GDP:       ', num2str(D_4Yi - D1_4Y)]);
  disp(['UI benefits:       ', num2str(nu_Yi - nu_Y)]);
  disp(['Avg hours:         ', num2str(NEi - NE)]);
  disp('-----------------------------------------------')

  % Check convergence of both, update if necessary
  if (res_cali < tol_cali) && (res_mkt < tol_mkt)
    break;
  else
    % discount factor
    btemp   = -log(1-bet);
    btemp   = btemp - .1*(Bi - B_4Y*4*Yi);
    bet     = 1 - exp(-btemp);

    % rest will be updated based on these
    phi_d  = phi * D1_4Y / D_4Yi;
    nu_d   = nu_Y * Yi;
    pssi_d = pssi * ((1-NE) / (1-NEi))^eta;

    phi  = phi  + 0.1 * (phi_d  - phi);
    nu   = nu   + 1   * (nu_d   - nu);
    pssi = pssi + 1   * (pssi_d - pssi);

    % Update aggregates
    B = B + 0.1 * (Bi - B);
  end
end

% Aggregate statistics
Y1   =  sum(sum(pd  .* y_pol));         % GDP
C1   =  sum(sum(pd  .* c_pol));         % consumption
D1   = -sum(sum(pd) .* min(b_grid, 0)); % debt
N1   =  sum(sum(pd  .* n_pol));         % labor supply (counting unemployed)
MPC1 =  sum(sum(pd .* mpcs));           % MPC

% Save results
phi1   = phi;
r1     = r;
pd1    = pd;
c_pol1 = c_pol;
b_pol1 = b_pol;

% Figure 1 in paper
figure(1)
ii = (b_grid> -phi) & (b_grid < 50*Y1); % domain

subplot(1, 2, 1)
plot(b_grid(ii)/(4*Y1), c_pol(2, ii), b_grid(ii)/(4*Y1), c_pol(8, ii), '--', 'LineWidth', 1.3);
title('consumption');
box on; grid on;
% set(gca,'FontSize', 14);
axis([-2 13 0 .6])

subplot(1, 2, 2)
plot(b_grid(ii)/(4*Y1), n_pol(2, ii), b_grid(ii)/(4*Y1), n_pol(8, ii), '--', 'LineWidth', 1.3);
title('labor supply');
legend('\theta^2','\theta^8');
box on; grid on;
% set(gca,'FontSize', 14);
axis([-2 13 -.1 .7])

set(gcf,'Position',  [440   378   700   300]);
set(gcf,'PaperPosition', [0   0   14   6]);
set(gcf,'PaperSize', [14 6]);
fig = gcf;
saveas(fig, 'fig1-policies.pdf');


%=========================================================================
%%                 3. Compute Terminal Steady State
%=========================================================================
% Only phi2 needs to be calibratd to match D2_4Y.

if rerun_terminal == 1
  phi = phi2;
  r   = r2;
end

% Use previous policy function as initial guess.
disp('Computing terminal equilibrium...');
for it = 1:maxit
  % Update budget constraint
  tau = (pr(1)*nu + r/(1+r)*B) / (1 - pr(1)); % labor tax
  z   = [nu, -tau*ones(1,S-1)];               % full transfer scheme (tau tilde in paper)

  % Find consumption at the lower bound of the state space
  for s = 1:S
    cl(s) = fzero('find_cl',...      % objective
                  [cmin, 100],...    % interval for bisection
                  [],...             % options
                  s, -phi, -phi, r); % state, assets, interest rate
  end

  % A) Solve for consumption policy
  %----------------------------------
  dif = 1;
  while dif > tol_pol
    % expected marginal utility tomorrow
    ui = Pr * c_pol.^(-gam);
    ui = ui(:, b_grid >= -phi);

    for s=1:S
      % unconstrained
      c = ((1+r) * bet * ui(s, :)) .^ (-1/gam);                   % Euler
      n = max(0, 1 - fac(s)*c.^gameta);                           % labor supply
      b = b_grid(b_grid >= -phi) / (1+r) + c - theta(s)*n - z(s); % budget

      % constrained
      if b(1) > -phi
          c_c = linspace(cl(s), c(1), Ic);
          n_c = max(0, 1 - fac(s)*c_c.^gameta);         % labor supply
          b_c = -phi/(1+r) + c_c - theta(s)*n_c - z(s); % budget
          b   = [b_c(1:Ic-1), b];
          c   = [c_c(1:Ic-1), c];
      end

      % interpolate between grid points, enforce non-negativity
      c_poli(s, :) = interp1(b, c, b_grid, 'linear', 'extrap');
      c_poli(s, :) = max(c_poli(s, :), cmin);
    end

    % check convergence
    dif    = max(max(abs(c_poli - c_pol)));

    % update
    c_pol = c_poli;
  end

  % Save other policy functions and MPCs
  for s = 1:S
    n_pol(s, :) = max(0, 1 - fac(s)*c_pol(s, :).^gameta);
    y_pol(s, :) = theta(s) * n_pol(s, :);
    b_pol(s, :) = max((1+r) * (b_grid + y_pol(s, :) - c_pol(s,:) + z(s)), -phi);
  end

  % B) Find invariant distribution
  %----------------------------------
  % Assign weights to adjacent grid points proportionally to distance
  [~, ~, ib_pol] = histcounts(b_pol, b_grid);
  wei            = (b_pol - b_grid(ib_pol)) ./ (b_grid(ib_pol+1) - b_grid(ib_pol));

  % Iterate asset transition matrix starting from uniform distribution
  dif = 1;
  pd  = ones(S,I) / (S*I);
  while dif > tol_dist
    pdi = zeros(S, I);
    for s = 1:S
      for i = 1:I
        for si = 1:S
          pdi(si, ib_pol(s, i))     = (1 - wei(s, i)) * Pr(s, si) * pd(s, i) + pdi(si, ib_pol(s, i));
          pdi(si, ib_pol(s, i) + 1) = wei(s, i)       * Pr(s, si) * pd(s, i) + pdi(si, ib_pol(s, i) + 1);
        end
      end
    end

    % check convergence
    dif = max(max(abs(pdi - pd)));

    % make sure that distribution integrates to 1
    pd = pdi / sum(sum(pdi));
  end

  % C) Check market clearing and calibration
  %-------------------------------------------------
  % Bond market clearing, i refers to current iteration
  Bi      = sum(sum(pd) .* b_grid);
  res_mkt = abs(B - Bi);

  % Calibration statistics, i refers to current iteration
  Di    = -sum(sum(pd) .* min(b_grid, 0));
  D_4Yi =  Di / Y1 / 4;                    % debt ratio to initial GDP
  res_cali = max(abs(D_4Yi - D2_4Y));

  % Report convergence
  disp(['Iteration ', num2str(it)]);
  disp(['Bond mkt clearing: ', num2str(B - Bi)]);
  disp(['Debt to GDP:       ', num2str(D_4Yi - D2_4Y)]);
  disp('-----------------------------------------------')

  % Check convergence of both, update if necessary
  if (res_cali < tol_cali) && (res_mkt < tol_mkt)
    break;
  else
    % interest rate
    r = r - 1/400*(Bi - B);

    % borrowing constraint
    phi_d = phi * D2_4Y / D_4Yi;
    phi   = phi  + 0.1 * (phi_d  - phi);
  end
end

% Aggregate statistics
Y2   =  sum(sum(pd  .* y_pol));         % GDP
C2   =  sum(sum(pd  .* c_pol));         % consumption
D2   = -sum(sum(pd) .* min(b_grid, 0)); % debt
N2   =  sum(sum(pd  .* n_pol));         % labor supply (counting unemployed)
MPC2 =  sum(sum(pd .* mpcs));           % MPC

% Save results
phi2   = phi;
r2     = r;
pd2    = pd;
c_pol2 = c_pol;
b_pol2 = b_pol;

%=========================================================================
%%                 3. Compate Initial and Terminal Steady States
%=========================================================================
% Domain for plot
ii = (b_grid > -phi1-.2) & (b_grid < 50*Y1);

% Figure 4 in paper
figure(2);
subplot(2, 1, 1);
hold on;
plot(b_grid(ii)/(4*Y1), (pr*b_pol1(:,ii) - b_grid(ii))/(4*Y1), 'LineWidth', 1.3);
plot(b_grid(ii)/(4*Y1), (pr*b_pol2(:,ii) - b_grid(ii))/(4*Y1), '--', 'LineWidth', 1.3);
hold off;
legend('initial ss', 'terminal ss'); title('saving policy')
% set(gca,'fontsize', 14);
box on; grid on;

subplot(2, 1, 2)
hold on;
plot(b_grid(ii)/(4*Y1), sum(pd1(:, ii)), 'LineWidth', 1.3)
plot(b_grid(ii)/(4*Y1), sum(pd2(:, ii)), '--', 'LineWidth', 1.3)
hold off;
title('distribution')
xlabel('b');
box on; grid on;

set(gcf,'PaperPosition', [0 0 7.5 6.5]);
set(gcf,'PaperSize', [7.5 6.6]);
fig=gcf;
saveas(fig,'fig4-intuition.pdf');

% Save objects to be used to calculate transition dynamics
save par bet gam eta pssi theta Pr pr S phi1 phi2 B nu fac gameta r1 r2 Y1 Y2 cmin
save steady r1 c_pol1 b_pol1 pd1 Y1 C1 N1 D1 MPC1 r2 c_pol2 b_pol2 pd2 Y2 C2 N2 D2
save grid I b_grid Ic
